# 20181204 ボトムアップDDD

## スライド

- <https://speakerdeck.com/nrslib/bottomup-ddd-1>
- <https://speakerdeck.com/nrslib/bottomup-ddd-2>

## 前編

- ユビキタス言語
- ドメインエキスパート
- エンティティー
- 辛さの原因
  - 知らないことが怖さの原因
- 用語
  - マインド
    - 感じるしかない
  - パターン
    - 実装できる
    - パターンが実装できれば怖さは半減できる

- 全容説明は難しい
  - ボトムアップ解説
  - 解説記事があるからスライドからリンクを抜き出す

- イントロダクションはセミナー
- Evansの本を読む下地を作る

- 値オブジェクト
  - 値って何ですか？
  - 値を示すオブジェクトも値らしくしよう

```csharp
var num = 1
num = 2
num.changeTo(2) とかやらない
```

```csharp
var text = "Hello"
text = "こんにちは"
```

- 値オブジェクトの続き
  - 値の性質
    - 状態を普遍に保つ
      - 状態 = フィールド
      - イミュータブルな状態ってことね
    - 値同士の比較ができる
      - a == a で比較できること
      - equalsで比較できる状態であること
      - 値の変更箇所の集約ができる
      - 比較は必要になった時に作ればいい
    - 完全に交換可能である
      - 交換以外の表現手段がなくなった
  - 表現力がます
  - 存在しない値を存在させない
    - ユーザ名長さを50と定義した時、コンストラクタで潰せる。存在してはいけないデータ値をここで潰す
  - 誤った代入を防ぐ
    - テーブル定義のドメイン定義に近い

- エンティティ
  - FWのエンティティとは違うぜ
  - 値オブジェクトの具役
  - 可変
  - 同じ属性でも区別される
    - 同姓同名は同じユーザとして良いか？
    - user1 == user2は一致させたくない（苗字と名前だけでは一致させない）
    - 識別子としてIDなどを追加する
  - 統一性をもつ
    - 属性が変わっても同じデータだと判別できるようにすること
  - ライフサイクルを持っている

- ドメインサービス
  - 全ての混乱の原因はサービスという言葉
  - エンティティや値オブジェクトで行うべきではない処理を記述するところ
  - チェック専用オブジェクトを作る
    - SAO的なサービスのことで良いか？

- 値オブジェクト、エンティティ、ドメインサービスでロジックは作れる
- データベースは大事
  - ロジックの大半を占める処理にDB接続のための処理が必要か

- リポジトリ
  - データの永続化を担うオブジェクト
  - 永続化の対象 = エンティティ
  - リポジトリのインターフェースを用意
    - 依存
      - 具象への依存
      - 特定のインフラへの依存

- アプリケーションサービス
  - ビジネスロジックのAPI
  - 何ができるかを表現する
  - ユースケースを表現する
  - エンティティ、値オブジェクト、ドメインサービス、リポジトリ、これらを強調さえてユースケースを達成させる
    - ようはアプリが作れる
    - DI (Dependency Injection) : 依存性の注入
  - アプリケーションのインターフェースを用意することもある
    - セパレートインターフェース
    - 何のためにやるのか？
      - 例外が発生した時の動作をチェックしたい
      - エラーがある状況を用意するのが大変
        - データを準備しなくても例外をただ発生させるためのサービスが作れる

- エンティティかドメイン、どちらに書くか悩んだ場合はエンティティに書くべし

- ファクトリ
  - エバックのファクトリ
  - 独自の裁判システムを使いたい時とか
    - ユーザの知識とユーザを作る知識は別物
    - ユーザがユーザの作り方を知っているのはおかしい
    - UserFactoryのインターフェースを作る
      - 生成処理をカプセル化しどのような仕組みでユーザが作られるかをドメインサービスが知る必要がなくなる
    - リポジトリに採番処理を持たせる場合もある
    - リポジトリ内で異なるプロトコルが集約されるのは違和感がある
      - 凝集度が異なる
    - DBの自動裁判は相性が悪い
      - saveするまでIDが不在になるのは違和感がでる

- トランザクション
  - ユニークキー制約したらいいんじゃない？
    - 重複チェックとか不要になるじゃん
      - わかりやすい？
      - 何もわからないソースになる（重複チェックが必要かどうかを判別できない）
  - トランザクションスコープ
    - C#ならトランザクションスコープで囲む
    - このスコープは生合成が求められる処理と主張している
  - Spring Framework
    - @Transactional
    - このメソッドは整合性が求めらえるという主張になる
  - なければ作ろう
  - ユニットオブワーク
    - 作業の単位 = 整合性の単位
    - DBConnectionを利用するところをUnitOfWorkを適用しやすい
    - C#のEntity Frameworkはユニットオブワークの実装

- 集約
  - 難しいで
  - サークル機能
  - ドメイン駆動設計はgeeterを使うわけがない！
    - getterを使ってアプリケーションサービスでファクトリを利用しサークルを作っていたが、Userにcreateメソッドを用意することでUserがサークルを作っているように見える
    - サークルの最大人数チェックがサークルへの参加のタイミングに直接実装されている場合がある
    - ドメインモデル貧血症
      - getter/setterしかないのでこのドメインが何をするものかわからない
      - Aggregate Root
        - アプリケーションサービスは集約ルートを直接のインターフェースにする
        - 集約はEntity
    - デメテルの法則
      - circle.Users.Add(newUser) -> circle.join(newUser)
  - 集約の粒度は？
    - エンティティの集まり
    - 変更の単位で作るべき
    - Circleの情報からUserを更新しないからUserはCircleの集約に含まれない
      - Circle集約にUserが変更される集約になると、Circleの中にUserの処理が多量に紛れ込んでしまう
    - リポジトリは集約ごとに作成することになる
    - 問題点
      - 変更できちゃう
      - circle.Users.First.ChangeName()とかできちゃう。保存されないけど
      - そもそもの問題は変更ができること
      - UserではなくUserId識別子に変更する
      - List<User>をgetterを公開しなきゃとかになるけど、リポジトリがアクセスできなくなるのは問題
      - C#の場合は、Notificationパターンで行う
        - 微妙！！
        - ロジックで縛るのではなくルールでの制約でいいじゃん
          - どうしてもダメなこがいる場合は、自動生成ツールを作って対応する
      - Scala最強説
        - 特定のクラスのみにアクセスできるクラスを定義する
        - private [アクセスを許すクラスメ名] メンバ変数

- ディレクトリ構成のイメージ
- ドメイン駆動と一緒に語られるアーキテクｆは
  - レイヤードアーキテクチャ
    - 依存の方向が下方向(Presentation -> Application -> Domain -> )
  - ヘキサゴナルsアーキテクチャ
    - adpterはinterfaces
    - ビジネスロジックが中心で依存は内向き
    - ビジネスロジックの変更は少ない
  - オニオンアーキテクチャ
    - ドメイン駆動設計を説明している
    - ヘキサゴナルアーキテクチャの内側
  - クリーンアーキテクチャ
    - Entity -> オニオンアーキテクチャ
    - ヘキサごなるアーキテクチャの外側

- まとめ
  - 依存関連の整理
  - 外界のいざこざにビジネスロジックの影響は受けてはならない
  - 真似ただけでは軽量DDD
  - どうしたら真のDDDにたどり着くのか
    - マインドを知ることが大切
    - ようは本を読めってこと

- ドメイン駆動設計はオブジェクト思考固有のものではない
  - ドメイン設計は関数型言語、構造化でも使える設計思想
  - オブジェクト思考
    - 今日の説明はオブジェクト思考
    - 難しい