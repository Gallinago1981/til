# 認証/認可

## 認証認可の連携プロトコル

- 認証プロトコル
  - ID/PWで照合する

- 主流のアクセス情報連携のプロトコル
  - SAML
    - 認証
    - XMLでメッセージ交換
    - 社内のSSO(SAML IoP)と連携ニーズ
    - エンタープライズ向け
  - OpenID Connect
    - 認証＋認可
    - JSON/Restベース
      - 開発容易性
    - 他社サービス間での情報連携
      - コンシューマ向け
    - エンタープライズ向けにも利用できる

- OAuth/OpenID Connectの誕生の背景
  - ユーザのリソースを他のアプリに安全に共有したい
  - ユーザの許可を持ってリソース情報を許可する

- OAuth策定
  - ユーザとシステム間で認可情報を扱うプロトコルとして策定

- 認証
  - ID/PWでユーザを識別
  - 認証よりによって確定されたユーザ情報を提供(OpenIDConnect)
- 認可
  - システムがあるユーザに特定の処理を行うことを許可
  - ユーザがシステムに自分のリソースに操作を行うことを許可(OAuth)

- OAuth認証
  - 認可は認証が前提
    - 認可を認証のだいたい手段として利用する(=OAuth認証)
- アクセストークンの悪用のリスク
  - implicitフローでは悪意のあるアプリがあっさりユーザのアクセストークンを取得して悪用が可能

- OAuthとOpenIDConnectの関係
- OAuth
  - 認可
- OPenID
  - 認可＋認証+ユーザ属性
- OAuthのプロトコルの上にシンプルなアイディンティティレイヤーとしての買っている

- アクセストークンのフォーマット
  - RFC7519 で定義
  - eyJで始まる

- アクセストークンの検証
  - リソースサーバ自身で検証
    - 署名検証
    - 自分自身宛か
    - アクセストークンの有効期限切れがチェックできない

  - 認可サーバの検証機能を利用
    - イントロスペクションエンドポイントを利用
    - 実装が用意
    - アクセストークンの取り消しの検知が可能

  - 疎結合なのでつどつどの検証が必要
  - クライアントタイプとOAuthタイプ
    - 機密クライアント
    - パブリッククライアント
      - 認可コードが奪われてしまうとクライアント側の認証がないので用意にアクセスできてしまう
      - 対策
        - PKC (RFC7636)

- OAuthのフロータイプ
  - 認可コードフロー
  - インプリシットフロー
  - など６タイプのフローがある

- OpenID Connect/OAuthと認証

  - OpenID Connect. OAuthではユーザそのものの認証方法は定めていない
    - 認可リクエスト後の認証画面は認可サーバ独自のもの
    - 独自の認証方式を実装する
      - ID/PW
      - ソーシャルログイン
  - 認証した情報をクライアントへ提供する仕組み

## Oracle Identity Cloud Service

- クラウドネイティブで実装されたIDaaS(ID as a Service)

## アプリケーション開発(UI)DEMO

- JavaEE& までの認証と認可
  - 保護するリソースをデプロイメントディスクリプたやアノテーションで指定
- アプリケーション開発者は基本的には認証と認可のためのプログラミングは不要
- SErvlet/JSPの認証と認可
  - アプリケーションの実行に必要な認証と認可の設定をweb.xmlに記述

- マイクロサービスとOAuth2.0/OpenID Connect
  - クライアント開発者
    - ユーザが認証済みかそうでないかのチェック
    - OAuth2.0のお作法にノットてアクセストークンを取得する
    - ユーザの権限に基づいた実装が必要
  - 保護対象リソースの開発者

  - HTTPヘッダーのAutherrization HeaderにBearerトークン
    - Github は別の名前にしてたりとかする
  - JWK(Json Web Key)
