# Spring Boot DDDサンプルコード

## git リポジトリ

- <https://github.com/system-sekkei/isolating-the-domain>

## isolating the domain

- ビジネスルールが複雑さの原因
- 計算をモデリング
  - データのモデリングはあまり関係にあ
  - 計算をどう表現するかが大切であり本質
  - ビジネスモデルを計算モデルとして考える
  - 値っていうのをどうやって値オブジェクトとして表現するのか
- 分離のこだわり
  - 計算を実行するモジュール軍
  - データを入出力するモジュール軍
- モジュール選択の選択
  - トランザクションスクリプトで作られていることが多い
  - 入出力の手続きの中でifや計算が行われている

- サンプルの概要
- ドメイン層(ビジネスルール層)
  - Payroll
    - Contract 契約条件
    - Attendance 労働時間 各日のりすとを保持する
  - ConstractWage
  - 計算モデルが息づく場所
    - modelパッケージ
      - 実際のビジネスモデル？
    - typeパッケージ
      - 型、小数点計算など
  - 型思考のプログラミング
    - イミュータブル型にするのであれば、private finalにすべき
    - ただし、ビジネスルールとして変更不可としてしまう如何なものか？
    - getter/setterは使わない
      - direct value access ?
    - Long, Integerの型ではなく計算結果として型
  - value()は無くしたい
    - primitiveな値が行き交うことをなくす方向で考える
    - パッケージ間での依存関係をなくす
  - stream apiのmapやreduceはビジネスロジックの表現とマッチしない
  - ビジネスロジックからstreamは消したい
    - 主要なとこでは使いたくない
  - IDEAでstream <-> for はすぐに変換できる
  - ドメインオブジェクトはドメインオブジェクトでこのデータはこうあるべきという制限をかけるべき
  - 計算するには
  - get/setがなくても意味が通じるのであれば、その方がいい
  - フィールドアクセスは行なってもいいと思っている
  - Validationは安易な方法に流されるのではなくシステムとして一貫性を持った方がいい
- アプリケーション層
  - Queryサービス
    - １つのリポジトリに対してin/outを行う -> 今回は
    - coordinatorクラス
      - 複数のサービスを複合したサービス
    - if/forなどは持たせない
      - ビジネスルール層で行う
  - Operationサービス
  - 計算モデルを作ることに特化した
    - ビジネスルール層で取り扱う単位のモデルを生成することに注力を当てる方針
- データソース層
  - MyBatis SQL Mapper
  - SELECTの実行 -> オブジェクトの生成
  - 記録すべき事実を持ったオブジェクト -> INSERTの実行
    - Dooma 土間？
  - テーブル設計とデータモデル設計が繋がってしまうのはよくない
  - SQLでマッピングすることができるので、自動生成などにひきづられないようにしたい
  - データベース
    - イミュータブルデータモデル
      - 履歴 + 最新状態レコード
      - 履歴 : 事実の記録 -> insert オンリー
      - 最新状態レコード: 論履歴には不要 -> INSERT/DELETE
        - 更新するのではなくDELETE/INSERTで最新状態を保つ
      - 全てCRATE & ADD
      - データ量が膨れ上がることは問題視されないか？
        - やっている規模感としては問題ない
        - パーティショニングなどを使うことで性能などはある程度、期待できる
        - 時系列データはわかりやすい
    - 正しく動くだけではなく、ソースで説明ができるような表現ができていると望ましい
    - 区分名は日本語で定義している
    - Triggerはアプリケーションから隠蔽されるからツライ
    - 外部システム
      - transfer層で行う（インフラ層）
      - inboundはController層に設けている
      - infrastrcture層で詰替を行なっている
    - アプリケーション層には外部の都合は入れない
    - ここでエラーが発生しないようにドメイン層で解決されていること
      - 発生するのはシステムエラーだけにするようなのがいい
      - ここで発生するエラーは利用者には関係ないことが多い
      - メッセージを積むにしてもException
- プレゼンテーション層
  - 設計モデルのビュー
    - naked object パラーん
  - SpringMVC
    - Direct Field Access -> WebDataBinder#initDirectFieldAccess()
      - これがdefault:false -> trueに変更してフィールドへのアクセスを有効にする
  - Thymeleft
    - CSS Framework : Semantic UI
    - モデルと画面描画の構造が合わない場合は、詰替を行う場合もある
    - JSONはモデルのデータ構造をそのまま変換させる
      - 嫌がられたら詰め直す

## jigツール (ビジネスルールの設計ドキュメント)

- 設計 -> コード -> ドキュメントのループを繰り返す
- コードがドキュメント見えればコードで設計できる
- いいコードはドキュメント化が容易
- not UML
  - 目的ではない
  - 他にも色々あるからね
  - ビジネスルールに際立つものと
- コードを読むときはいつも同じ
- dddjavaJig
  - java -jar 
  - gradle pluginもあるよ
    - ./gradlew jig

- ビジネスルール用語集が出来上がる
  - ユビキタス言語っぽくなる
- package-info,htmlに埋め込まれているパッケージ説明で構造が出力される
- 最初から綺麗にできているわけではない
- 相互参照の場合は赤字で表示される
- 区分enum構造が複雑になりがちになる
- ツリー構造
- 型のネットワーク構造
  - 無意識かの構造と機械的な構造のギャップを見ることで新しい検討内容を見つけることができる

## QA

- かかった時間
  - リファクタリングにかけた時間
  - １ヶ月くらい
  - 業務について知見がある人とは話すことで中心に捉えるドメインが変わった
- private final を約束事にしないことのリスク
  - 要は教育
  - ルールとして制約かけたとこで守られない
- 教育について
  - Java のプログラミングを正しく行う
    - int + int はオーバーフローするけどMath.addだとしないよね <- こういう基本的なことを正しく理解させる。型指向というのを理解させる方法を模索する
    - 型についての意識をどう持たせるかが大切
  - クラスを自分で作れるはハードルが高い
- 大規模開発
  - モジュール分割
  - 少数精鋭
- 形式手法
  - 静的な型付け言語はミニマムな形式手法と言えるのではないか？
  - あとで調べる！